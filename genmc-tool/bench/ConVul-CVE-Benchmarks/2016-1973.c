#include <stdio.h>
#include <pthread.h>
#include <assert.h>
#include <unistd.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>
#include <sys/time.h>
#include <stdatomic.h>

typedef _Atomic(void*) atomic_voidptr;


// #define SLEEP_FOR_RACE
// #define TEST_TIME

// 定义枚举类型
typedef enum {
	kRelease,
	kAddRef,
	kAddRefNoCreate
} CountOperation;

typedef enum {
	kInstanceExists,
	kCreate,
	kDestroy
} CreateOperation;

long _InterlockedIncrement(volatile atomic_long* ref) {
    return atomic_fetch_add(ref, 1) + 1;
}

long _InterlockedDecrement(volatile atomic_long* ref) {
    return atomic_fetch_sub(ref, 1) - 1;
}

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement

static inline void* InterlockedExchangePointer(void* volatile* target, void* value) {
    return atomic_exchange((atomic_voidptr*)target, value);
}

typedef struct SSRCDatabase {
    uint32_t _ssrcMap[128];  // 用数组模拟 map，简化示例
} SSRCDatabase;

// 创建 SSRCDatabase 实例
SSRCDatabase* SSRCDatabase_CreateInstance() {
    return (SSRCDatabase*)malloc(sizeof(SSRCDatabase));
}

// 销毁 SSRCDatabase 实例
void SSRCDatabase_DestroyInstance(SSRCDatabase* instance) {
    free(instance);
}

// 使用模板的逻辑改为函数指针
static SSRCDatabase* GetStaticInstance(CountOperation count_operation, int thread_num) {
    static volatile atomic_long instance_count = 0;
    static SSRCDatabase* volatile instance = NULL;
    CreateOperation state = kInstanceExists;

    if (count_operation == kAddRefNoCreate && instance_count == 0) {
        return NULL;
    }
    if (count_operation == kAddRefNoCreate) {
        if (1 == InterlockedIncrement(&instance_count)) {
            InterlockedDecrement(&instance_count);
            assert(0);
            return NULL;
        }
        if (instance == NULL) {
            assert(0);
            InterlockedDecrement(&instance_count);
            return NULL;
        }
    } else if (count_operation == kAddRef) {
        printf("thread %d: kAddRef\n", thread_num);
        if (instance_count == 0) {
            state = kCreate;
            printf("thread %d: count = 0, state = kCreate\n", thread_num);
        } else {
            printf("thread %d: count != 0\n", thread_num);
            if (1 == InterlockedIncrement(&instance_count)) {
                printf("thread %d: count++, count == 1\n", thread_num);
                InterlockedDecrement(&instance_count);
                state = kCreate;
                printf("thread %d: count--, state = kCreate\n", thread_num);
            }
        }
    } else {
        int new_value = InterlockedDecrement(&instance_count);
        printf("thread %d: count--, new_value = %d\n", thread_num, new_value);
        if (new_value == 0) {
            state = kDestroy;
            printf("thread %d: set state = kDestroy\n", thread_num);
        }
    }

    if (state == kCreate) {
        printf("thread %d: kCreate\n", thread_num);
        SSRCDatabase* new_instance = SSRCDatabase_CreateInstance();
        printf("thread %d: new_instance\n", thread_num);
#ifdef SLEEP_FOR_RACE
        if(thread_num == 1)
            sleep(3);
        else sleep(4);
#endif
        if (1 == InterlockedIncrement(&instance_count)) {
            printf("thread %d: count++, count == 1\n", thread_num);
            InterlockedExchangePointer((void**)&instance, new_instance);
            printf("thread %d: exchange new_instance, instance\n", thread_num);
        } else {
            InterlockedDecrement(&instance_count);
            printf("thread %d: count--\n", thread_num);
            if (new_instance) {
                SSRCDatabase_DestroyInstance(new_instance);
                printf("thread %d: delete new_instance\n", thread_num);
            }
        }
    } else if (state == kDestroy) {
        printf("thread %d: kDestroy\n", thread_num);
        SSRCDatabase* old_value = (SSRCDatabase*)InterlockedExchangePointer((void**)&instance, NULL);
        printf("thread %d: exchange, instance, NULL\n", thread_num);
        if (old_value) {
            printf("thread %d: old_value = %p\n", thread_num, old_value);
            SSRCDatabase_DestroyInstance(old_value);
            printf("thread %d: delete old_value\n", thread_num);
        }
        return NULL;
    }

    return instance;
}

// 访问 map（模拟访问 _ssrcMap 数组）
int accessMap(SSRCDatabase* ssrcdb) {
    return sizeof(ssrcdb->_ssrcMap) / sizeof(uint32_t);
}

// 线程 1
void* thread_one(void* args) {
    SSRCDatabase* ssrcdb = GetStaticInstance(kAddRef, 1);
    printf("thread 1: ssrcdb = %p\n", ssrcdb);
    accessMap(ssrcdb);
#ifdef SLEEP_FOR_RACE
    sleep(5);
#endif
    GetStaticInstance(kRelease, 1);
    return NULL;
}

// 线程 2
void* thread_two(void* args) {
#ifdef SLEEP_FOR_RACE
    sleep(2);
#endif
    SSRCDatabase* ssrcdb = GetStaticInstance(kAddRef, 2);
    printf("thread 2: ssrcdb = %p\n", ssrcdb);
#ifdef SLEEP_FOR_RACE
    sleep(6);
#endif
    accessMap(ssrcdb);
    printf("thread 2: use ssrcdb = %p\n", ssrcdb);
    return NULL;
}

int main() {
#ifdef TEST_TIME
    static double run_time_begin;
    static double run_time_end;
    static double run_time_total;
    run_time_begin = clock();
#endif

    pthread_t t1, t2;

    pthread_create(&t2, NULL, thread_two, NULL);
    pthread_create(&t1, NULL, thread_one, NULL);

    pthread_join(t2, NULL);
    pthread_join(t1, NULL);

    printf("\nprogram-successful-exit\n");

#ifdef TEST_TIME
    run_time_end = clock();
    run_time_total = run_time_end - run_time_begin;
    printf("test-the-total-time: %.3lf ms\n", (double)(run_time_total / CLOCKS_PER_SEC) * 1000);
#endif

    return 0;
}
